function [ isaac_table ] = isaac_struct2table( isaac_struct, varargin )
%   isaac_table = isaac_struct2table( isaac_struct, 'name1', value1, ... )
% converts metrics in struct format, as generated by isaac_concatenate, to
% table format, e.g. for input to external statistics software. Each row
% represents a dataset (i.e. isaac metrics from one subject/session/run)
% column represents a metric (e.g. Var, DCorr) and a region or pair of
% regions.
%
%
% inputs:
%     (mandatory)
%
%     isaac_struct:
%         As in the output of isaac_concatenate
%
%     (optional in name-value pairs)
%
%     'do_output_several_tables':
%         Flag to output a separate table per metric. It is by default
%         false, but if many regions are used, there might be too many
%         columns in the output.
%
%     'file_out':
%         If speficied, the output table will be saved to the file path
%         file_out (in tsv). If not, the metrics will be output as a matlab
%         variable. If do_output_several_tables is true, several files will
%         be saved to file_out_MetricNameInPascalCase.tsv.
%
% outputs:
%      isaac_table
%          The table(s) with the metrics. If do_output_several_tables is
%          true, the output will be a struct with each field containing a
%          table.
%
%          Each row contains the metrics of a dataset, and each column a
%          metric. Column names are chosen so that they are easy to parse
%          (provided region names have no '_'), and are always of the form:
%            ColumnNameInPascalCase
%               (for dataset metrics, e.g. DatasetId, NTimepoints)
%            MetricNameInPascalCase_RegionName
%               (for local metrics)
%            MetricNameInPascalCase_RegionNameX_RegionNameY
%               (for shared metrics)
%


% --------------- parse args ----------------------------------------------
if rem(length(varargin), 2)
    warning('Odd number of optional arguments. Optional arguments must be in name-value pairs');
end

% default values:
file_out   = '';
do_output_several_tables   = false;

% If any values were specified, change the value:
for k = 1:2:length(varargin)
    name_ = varargin{k};
    switch name_
        case 'do_output_several_tables';
            do_output_several_tables = varargin{k+1};
        case 'file_out';
            file_out = varargin{k+1};
        otherwise
            warning('Parameter ''%s'' not recognized, it will be ignored', name_);
    end
end
do_save = ~isempty(file_out);



% detect if input is a file or a struct:
% load all the input files in an array of structs:
switch class(isaac_struct)
    case 'char'
        isaac_struct_file = isaac_struct;
        % input is a cell of strings containing paths
        isaac_struct = load(isaac_struct_file);
        
    case 'struct'
        % do nothing really
    otherwise
        error('Input should be a struct or a file path, as the output by isaac_concatenate_files, but instead is %s',...
            class(isaac_struct));
end



% ------------- do the thing ----------------------------------------------
% output all the metrics, with the dataset_id as the first column.
isaac_info_table = array2table(isaac_struct.info.dataset_id(:));
isaac_info_table.Properties.VariableNames = {'DatasetId'};
% add some metadata to the table
isaac_info_table.BxEstimationMethod   = squeeze(isaac_struct.info.bx_estimation_method);
isaac_info_table.FisherAverageCorrs   = squeeze(isaac_struct.info.do_fisher_average_corrs);
isaac_info_table.ForcedHomNonnegative = squeeze(isaac_struct.info.do_force_hom_nonnegative);
isaac_info_table.FisherTransCorrs     = squeeze(isaac_struct.info.fisher_transformed_corrs);
isaac_info_table.Log10TransVars       = squeeze(isaac_struct.info.log10_transformed_vars);
isaac_info_table.NTimePoints          = squeeze(isaac_struct.info.n_time_points);

isaac_table = isaac_info_table;

% get Y regions that are not in x, avoid store twice the same region:
idx_unique_y = find(~ismember(isaac_struct.info.roi_names_y, isaac_struct.info.roi_names_x));


% Number of voxels:
for k1 = 1:length(isaac_struct.info.roi_names_x)
    col_name = ['NVoxels_' isaac_struct.info.roi_names_x{k1}];
    isaac_table.(col_name) = squeeze(isaac_struct.info.n_voxels_x(1,k1,:));
end

for k2 = idx_unique_y(:)'
    col_name = ['NVoxels_' isaac_struct.info.roi_names_y{k2}];
    isaac_table.(col_name) = squeeze(isaac_struct.info.n_voxels_y(1,k2,:));
end



% Mean signal metrics, first local, then shared
for k1 = 1:length(isaac_struct.info.roi_names_x)
    col_name = ['MeanSignalsVar_' isaac_struct.info.roi_names_x{k1}];
    isaac_table.(col_name) = squeeze(isaac_struct.meansignals.var_x(k1,:,:));
end

for k2 = idx_unique_y
    col_name = ['MeanSignalsVar_' isaac_struct.info.roi_names_y{k2}];
    isaac_table.(col_name) = squeeze(isaac_struct.meansignals.var_y(k2,:,:));
end

for k1 = 1:length(isaac_struct.info.roi_names_x)
    for k2 = 1:length(isaac_struct.info.roi_names_y)
        % avoid repeated columns, in case there are:
        if ismember(isaac_struct.info.roi_names_y(k2), isaac_struct.info.roi_names_x(1:k1)), continue; end
        col_name = ['MeanSignalsCorr_' isaac_struct.info.roi_names_x{k1} '_' isaac_struct.info.roi_names_y{k2}];
        isaac_table.(col_name) = squeeze(isaac_struct.meansignals.corr(k1,k2,:));
    end
end

for k1 = 1:length(isaac_struct.info.roi_names_x)
    for k2 = 1:length(isaac_struct.info.roi_names_y)
        % avoid repeated columns, in case there are:
        if ismember(isaac_struct.info.roi_names_y(k2), isaac_struct.info.roi_names_x(1:k1)), continue; end
        col_name = ['MeanSignalsCov_' isaac_struct.info.roi_names_x{k1} '_' isaac_struct.info.roi_names_y{k2}];
        isaac_table.(col_name) = squeeze(isaac_struct.meansignals.cov(k1,k2,:));
    end
end



% Descriptive metrics, first local, then shared
for k1 = 1:length(isaac_struct.info.roi_names_x)
    col_name = ['Var_' isaac_struct.info.roi_names_x{k1}];
    isaac_table.(col_name) = squeeze(isaac_struct.descriptive.var_x(k1,:,:));
end

for k2 = idx_unique_y
    col_name = ['Var_' isaac_struct.info.roi_names_y{k2}];
    isaac_table.(col_name) = squeeze(isaac_struct.descriptive.var_y(k2,:,:));
end

for k1 = 1:length(isaac_struct.info.roi_names_x)
    col_name = ['Hom_' isaac_struct.info.roi_names_x{k1}];
    isaac_table.(col_name) = squeeze(isaac_struct.descriptive.hom_x(k1,:,:));
end

for k2 = idx_unique_y
    col_name = ['Hom_' isaac_struct.info.roi_names_y{k2}];
    isaac_table.(col_name) = squeeze(isaac_struct.descriptive.hom_y(k2,:,:));
end

for k1 = 1:length(isaac_struct.info.roi_names_x)
    for k2 = 1:length(isaac_struct.info.roi_names_y)
        % avoid repeated columns, in case there are:
        if ismember(isaac_struct.info.roi_names_y(k2), isaac_struct.info.roi_names_x(1:k1)), continue; end
        col_name = ['DCorr_' isaac_struct.info.roi_names_x{k1} '_' isaac_struct.info.roi_names_y{k2}];
        isaac_table.(col_name) = squeeze(isaac_struct.descriptive.dcorr(k1,k2,:));
    end
end



% Inferential metrics, first local, then shared
for k1 = 1:length(isaac_struct.info.roi_names_x)
    col_name = ['HVar_' isaac_struct.info.roi_names_x{k1}];
    isaac_table.(col_name) = squeeze(isaac_struct.inferential.hvar_x(k1,:,:));
end

for k2 = idx_unique_y
    col_name = ['HVar_' isaac_struct.info.roi_names_y{k2}];
    isaac_table.(col_name) = squeeze(isaac_struct.inferential.hvar_y(k2,:,:));
end

for k1 = 1:length(isaac_struct.info.roi_names_x)
    col_name = ['UVar_' isaac_struct.info.roi_names_x{k1}];
    isaac_table.(col_name) = squeeze(isaac_struct.inferential.uvar_x(k1,:,:));
end

for k2 = idx_unique_y
    col_name = ['UVar_' isaac_struct.info.roi_names_y{k2}];
    isaac_table.(col_name) = squeeze(isaac_struct.inferential.uvar_y(k2,:,:));
end

for k1 = 1:length(isaac_struct.info.roi_names_x)
    for k2 = 1:length(isaac_struct.info.roi_names_y)
        % avoid repeated columns, in case there are:
        if ismember(isaac_struct.info.roi_names_y(k2), isaac_struct.info.roi_names_x(1:k1)), continue; end
        col_name = ['SVar_' isaac_struct.info.roi_names_x{k1} '_' isaac_struct.info.roi_names_y{k2}];
        isaac_table.(col_name) = squeeze(isaac_struct.inferential.svar_xy(k1,k2,:));
    end
end

for k1 = 1:length(isaac_struct.info.roi_names_x)
    for k2 = 1:length(isaac_struct.info.roi_names_y)
        % avoid repeated columns, in case there are:
        if ismember(isaac_struct.info.roi_names_y(k2), isaac_struct.info.roi_names_x(1:k1)), continue; end
        col_name = ['IvarX_' isaac_struct.info.roi_names_x{k1} '_' isaac_struct.info.roi_names_y{k2}];
        isaac_table.(col_name) = squeeze(isaac_struct.inferential.ivar_xyx(k1,k2,:));
    end
end

for k1 = 1:length(isaac_struct.info.roi_names_x)
    for k2 = 1:length(isaac_struct.info.roi_names_y)
        % avoid repeated columns, in case there are:
        if ismember(isaac_struct.info.roi_names_y(k2), isaac_struct.info.roi_names_x(1:k1)), continue; end
        col_name = ['IvarY_' isaac_struct.info.roi_names_x{k1} '_' isaac_struct.info.roi_names_y{k2}];
        isaac_table.(col_name) = squeeze(isaac_struct.inferential.ivar_xyy(k1,k2,:));
    end
end

for k1 = 1:length(isaac_struct.info.roi_names_x)
    for k2 = 1:length(isaac_struct.info.roi_names_y)
        % avoid repeated columns, in case there are:
        if ismember(isaac_struct.info.roi_names_y(k2), isaac_struct.info.roi_names_x(1:k1)), continue; end
        col_name = ['Bx_' isaac_struct.info.roi_names_x{k1} '_' isaac_struct.info.roi_names_y{k2}];
        isaac_table.(col_name) = squeeze(isaac_struct.inferential.bx(k1,k2,:));
    end
end



% -------- save table ----------------------------
if do_save
    % if file_out is a dir, add file name. if it doesn't end with .tsv, add
    % .tsv.
    is_dir_file_out = (file_out(end)=='/') || (file_out(end)=='\') || isdir(file_out);
    is_tsv_file_out = ~isempty(regexp(file_out, '\.tsv$'));
    if is_dir_file_out
        dir_out = file_out;
        file_out = fullfile(dir_out, sprintf('isaac_metrics_table_%s.tsv', datestr(now, 'yyyymmdd_HHMMSSFFF')));
        warning('Output file name ''%s'' is a directory. Data will be saved to ''%s''',...
            dir_out, file_out);
    else
        dir_out = fileparts(file_out);
        if ~is_tsv_file_out
            file_out = [file_out '.tsv'];
        end
    end
    
    % at this point it should end with .tsv
    [p, f, e] = fileparts(file_out);
    
    % if output directory doesn't exist, create it.
    if ~exist(dir_out, 'dir')
        mkdir(dir_out);
    end
    
    if ~do_output_several_tables
        writetable(isaac_table, file_out ...
            ,'FileType', 'text' ...
            ,'Delimiter', '\t');
    else
        
        % split in several tables:
        % info columns refer to no region:
        cols_info = cellfun(@cell2mat, regexp(isaac_table.Properties.VariableNames, '^[^_]*$', 'match'), 'uni', false)';
        cols_info(cellfun(@isempty, cols_info)) = {''};
        % data columns refer to some region or region pair:
        cols_data = cellfun(@cell2mat, regexp(isaac_table.Properties.VariableNames, '^[^_]*_', 'match'), 'uni', false)';
        cols_data(cellfun(@isempty, cols_data)) = {''};
        cols_data = regexprep(cols_data, '_$', '');
        cols_data_unique = unique(cols_data(~cellfun(@isempty, cols_data)), 'stable');
        isaac_tables = struct;
        
        isaac_tables.Info = isaac_table(:,[1 find(ismember(isaac_table.Properties.VariableNames(:), cols_info))']);
        
        for k_col = 1:length(cols_data_unique)
            isaac_tables.(cols_data_unique{k_col}) = isaac_table(:,[1 find(ismember(cols_data, cols_data_unique(k_col)))']);
        end
        
        for fn = fieldnames(isaac_tables)'
            file_out_ = fullfile(p, [f, '_' fn{1} e]);
            writetable(isaac_tables.(fn{1}), file_out_ ...
                ,'FileType', 'text' ...
                ,'Delimiter', '\t');
        end
    end
end

